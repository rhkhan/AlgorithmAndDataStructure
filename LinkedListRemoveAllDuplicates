// Remove duplicates
// from a sorted linked list; Time complexity O(n), Space complexity O(1)
void removeDuplicates()
    {
        /*Another reference to head*/
        Node current = head;
        
        /* do nothing if the list is empty */
        if (head == null)
            return;
 
        /* Traverse list till the last node */
        while (current.next != null)
        {
 
            /*Compare current node with the next node */
            if (current.data == current.next.data)
            {
                current.next = current.next.next;
            }
            else // advance if no deletion
                current = current.next;
        }
    }
    
 // Recursive function to remove duplicates
// from a sorted list; TimeComplexity O(n), Auxilary space O(n)
static Node removeDuplicates(Node head)
{
    /* do nothing if the list is empty */
    if (head == null)
        return null;
 
    /* Traverse the list till last node */
    if (head.next != null)
    {
        /* Compare head node with next node */
        if (head.data == head.next.data)
        {
            head.next = head.next.next;
            removeDuplicates(head);
        }
        /* traverse the list */
        else
        {
            removeDuplicates(head.next);
        }
    }
    return head;
}

/* Function to remove duplicates from an
         unsorted linked list; TimeComplexity O(n^2) */
    void remove_duplicates()
    {
        Node ptr1 = null, ptr2 = null, dup = null;
        ptr1 = head;
 
        /* Pick elements one by one */
        while (ptr1 != null && ptr1.next != null) {
            ptr2 = ptr1;
 
            /* Compare the picked element with rest
                      of the elements */
            while (ptr2.next != null) {
 
                /* If duplicate then delete it */
                if (ptr1.data == ptr2.next.data) {
 
                    /* sequence of steps is important here
                     */
                    dup = ptr2.next;
                    ptr2.next = ptr2.next.next;
                }
                else /* This is tricky */
                {
                    ptr2 = ptr2.next;
                }
            }
            ptr1 = ptr1.next;
        }
    }
    
    // Function to remove duplicates from a
    // unsorted linked list; TimeComplexity O(n)
    static void removeDuplicate(node head)
    {
 
        // Hash to store seen values
        HashSet<int> hs = new HashSet<int>();
 
        // Pick elements one by one
        node current = head;
        node prev = null;
        while (current != null) {
            int curval = current.val;
 
            // If current value is seen before
            if (hs.Contains(curval)) {
                prev.next = current.next;
            }
            else {
                hs.Add(curval);
                prev = current;
            }
            current = current.next;
        }
    }
